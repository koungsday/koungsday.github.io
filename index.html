<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prismatic Burst Effect</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            font-family: system-ui, -apple-system, sans-serif;
        }
        
        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            color: white;
            min-width: 200px;
            backdrop-filter: blur(10px);
        }
        
        #controls h3 {
            margin-bottom: 15px;
            font-size: 16px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        .control-group input[type="range"] {
            width: 100%;
        }
        
        .control-group select {
            width: 100%;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
        }
        
        .control-group button {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        .control-group button:hover {
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="controls">
        <h3>Controls</h3>
        
        <div class="control-group">
            <label>Intensity: <span id="intensityVal">2.0</span></label>
            <input type="range" id="intensity" min="0" max="5" step="0.1" value="2">
        </div>
        
        <div class="control-group">
            <label>Speed: <span id="speedVal">0.5</span></label>
            <input type="range" id="speed" min="0" max="2" step="0.1" value="0.5">
        </div>
        
        <div class="control-group">
            <label>Animation Type:</label>
            <select id="animType">
                <option value="0">Rotate</option>
                <option value="1" selected>Rotate 3D</option>
                <option value="2">Hover</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Distortion: <span id="distortVal">0</span></label>
            <input type="range" id="distort" min="0" max="10" step="0.5" value="0">
        </div>
        
        <div class="control-group">
            <label>Ray Count: <span id="rayCountVal">0</span></label>
            <input type="range" id="rayCount" min="0" max="12" step="1" value="0">
        </div>
        
        <div class="control-group">
            <button id="pauseBtn">Pause</button>
        </div>
    </div>

    <script>
        const vertexShader = `#version 300 es
            in vec2 position;
            in vec2 uv;
            out vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        const fragmentShader = `#version 300 es
            precision highp float;
            precision highp int;

            out vec4 fragColor;

            uniform vec2  uResolution;
            uniform float uTime;
            uniform float uIntensity;
            uniform float uSpeed;
            uniform int   uAnimType;
            uniform vec2  uMouse;
            uniform int   uColorCount;
            uniform float uDistort;
            uniform vec2  uOffset;
            uniform sampler2D uGradient;
            uniform float uNoiseAmount;
            uniform int   uRayCount;

            float hash21(vec2 p){
                p = floor(p);
                float f = 52.9829189 * fract(dot(p, vec2(0.065, 0.005)));
                return fract(f);
            }

            mat2 rot30(){ return mat2(0.8, -0.5, 0.5, 0.8); }

            float layeredNoise(vec2 fragPx){
                vec2 p = mod(fragPx + vec2(uTime * 30.0, -uTime * 21.0), 1024.0);
                vec2 q = rot30() * p;
                float n = 0.0;
                n += 0.40 * hash21(q);
                n += 0.25 * hash21(q * 2.0 + 17.0);
                n += 0.20 * hash21(q * 4.0 + 47.0);
                n += 0.10 * hash21(q * 8.0 + 113.0);
                n += 0.05 * hash21(q * 16.0 + 191.0);
                return n;
            }

            vec3 rayDir(vec2 frag, vec2 res, vec2 offset, float dist){
                float focal = res.y * max(dist, 1e-3);
                return normalize(vec3(2.0 * (frag - offset) - res, focal));
            }

            float edgeFade(vec2 frag, vec2 res, vec2 offset){
                vec2 toC = frag - 0.5 * res - offset;
                float r = length(toC) / (0.5 * min(res.x, res.y));
                float x = clamp(r, 0.0, 1.0);
                float q = x * x * x * (x * (x * 6.0 - 15.0) + 10.0);
                float s = q * 0.5;
                s = pow(s, 1.5);
                float tail = 1.0 - pow(1.0 - s, 2.0);
                s = mix(s, tail, 0.2);
                float dn = (layeredNoise(frag * 0.15) - 0.5) * 0.0015 * s;
                return clamp(s + dn, 0.0, 1.0);
            }

            mat3 rotX(float a){ float c = cos(a), s = sin(a); return mat3(1.0,0.0,0.0, 0.0,c,-s, 0.0,s,c); }
            mat3 rotY(float a){ float c = cos(a), s = sin(a); return mat3(c,0.0,s, 0.0,1.0,0.0, -s,0.0,c); }
            mat3 rotZ(float a){ float c = cos(a), s = sin(a); return mat3(c,-s,0.0, s,c,0.0, 0.0,0.0,1.0); }

            vec3 sampleGradient(float t){
                t = clamp(t, 0.0, 1.0);
                return texture(uGradient, vec2(t, 0.5)).rgb;
            }

            vec2 rot2(vec2 v, float a){
                float s = sin(a), c = cos(a);
                return mat2(c, -s, s, c) * v;
            }

            float bendAngle(vec3 q, float t){
                float a = 0.8 * sin(q.x * 0.55 + t * 0.6)
                        + 0.7 * sin(q.y * 0.50 - t * 0.5)
                        + 0.6 * sin(q.z * 0.60 + t * 0.7);
                return a;
            }

            void main(){
                vec2 frag = gl_FragCoord.xy;
                float t = uTime * uSpeed;
                float jitterAmp = 0.1 * clamp(uNoiseAmount, 0.0, 1.0);
                vec3 dir = rayDir(frag, uResolution, uOffset, 1.0);
                float marchT = 0.0;
                vec3 col = vec3(0.0);
                float n = layeredNoise(frag);
                vec4 c = cos(t * 0.2 + vec4(0.0, 33.0, 11.0, 0.0));
                mat2 M2 = mat2(c.x, c.y, c.z, c.w);
                float amp = clamp(uDistort, 0.0, 50.0) * 0.15;

                mat3 rot3dMat = mat3(1.0);
                if(uAnimType == 1){
                    vec3 ang = vec3(t * 0.31, t * 0.21, t * 0.17);
                    rot3dMat = rotZ(ang.z) * rotY(ang.y) * rotX(ang.x);
                }
                mat3 hoverMat = mat3(1.0);
                if(uAnimType == 2){
                    vec2 m = uMouse * 2.0 - 1.0;
                    vec3 ang = vec3(m.y * 0.6, m.x * 0.6, 0.0);
                    hoverMat = rotY(ang.y) * rotX(ang.x);
                }

                for (int i = 0; i < 44; ++i) {
                    vec3 P = marchT * dir;
                    P.z -= 2.0;
                    float rad = length(P);
                    vec3 Pl = P * (10.0 / max(rad, 1e-6));

                    if(uAnimType == 0){
                        Pl.xz *= M2;
                    } else if(uAnimType == 1){
                        Pl = rot3dMat * Pl;
                    } else {
                        Pl = hoverMat * Pl;
                    }

                    float stepLen = min(rad - 0.3, n * jitterAmp) + 0.1;

                    float grow = smoothstep(0.35, 3.0, marchT);
                    float a1 = amp * grow * bendAngle(Pl * 0.6, t);
                    float a2 = 0.5 * amp * grow * bendAngle(Pl.zyx * 0.5 + 3.1, t * 0.9);
                    vec3 Pb = Pl;
                    Pb.xz = rot2(Pb.xz, a1);
                    Pb.xy = rot2(Pb.xy, a2);

                    float rayPattern = smoothstep(
                        0.5, 0.7,
                        sin(Pb.x + cos(Pb.y) * cos(Pb.z)) *
                        sin(Pb.z + sin(Pb.y) * cos(Pb.x + t))
                    );

                    if (uRayCount > 0) {
                        float ang = atan(Pb.y, Pb.x);
                        float comb = 0.5 + 0.5 * cos(float(uRayCount) * ang);
                        comb = pow(comb, 3.0);
                        rayPattern *= smoothstep(0.15, 0.95, comb);
                    }

                    vec3 spectralDefault = 1.0 + vec3(
                        cos(marchT * 3.0 + 0.0),
                        cos(marchT * 3.0 + 1.0),
                        cos(marchT * 3.0 + 2.0)
                    );

                    float saw = fract(marchT * 0.25);
                    float tRay = saw * saw * (3.0 - 2.0 * saw);
                    vec3 userGradient = 2.0 * sampleGradient(tRay);
                    vec3 spectral = (uColorCount > 0) ? userGradient : spectralDefault;
                    vec3 base = (0.05 / (0.4 + stepLen))
                              * smoothstep(5.0, 0.0, rad)
                              * spectral;

                    col += base * rayPattern;
                    marchT += stepLen;
                }

                col *= edgeFade(frag, uResolution, uOffset);
                col *= uIntensity;

                fragColor = vec4(clamp(col, 0.0, 1.0), 1.0);
            }
        `;

        class PrismaticBurst {
            constructor(container) {
                this.container = container;
                this.paused = false;
                this.mouseTarget = [0.5, 0.5];
                this.mouseSmooth = [0.5, 0.5];
                this.accumTime = 0;
                this.lastTime = performance.now();
                
                this.init();
            }

            init() {
                const canvas = document.createElement('canvas');
                canvas.style.mixBlendMode = 'lighten';
                this.container.appendChild(canvas);
                
                const gl = canvas.getContext('webgl2', {
                    alpha: false,
                    antialias: false
                });
                
                if (!gl) {
                    alert('WebGL2가 지원되지 않습니다.');
                    return;
                }
                
                this.gl = gl;
                this.canvas = canvas;
                
                this.setupShaders();
                this.setupGeometry();
                this.setupTexture();
                this.setupUniforms();
                this.resize();
                
                window.addEventListener('resize', () => this.resize());
                this.container.addEventListener('pointermove', (e) => this.onPointerMove(e));
                
                this.animate();
            }

            setupShaders() {
                const gl = this.gl;
                
                const vs = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vs, vertexShader);
                gl.compileShader(vs);
                
                const fs = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fs, fragmentShader);
                gl.compileShader(fs);
                
                this.program = gl.createProgram();
                gl.attachShader(this.program, vs);
                gl.attachShader(this.program, fs);
                gl.linkProgram(this.program);
                
                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                    console.error('Shader linking failed:', gl.getProgramInfoLog(this.program));
                }
                
                gl.useProgram(this.program);
            }

            setupGeometry() {
                const gl = this.gl;
                
                const vertices = new Float32Array([
                    -1, -1,  0, 0,
                     3, -1,  2, 0,
                    -1,  3,  0, 2
                ]);
                
                const vbo = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                
                const posLoc = gl.getAttribLocation(this.program, 'position');
                const uvLoc = gl.getAttribLocation(this.program, 'uv');
                
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 16, 0);
                
                gl.enableVertexAttribArray(uvLoc);
                gl.vertexAttribPointer(uvLoc, 2, gl.FLOAT, false, 16, 8);
            }

            setupTexture() {
                const gl = this.gl;
                
                this.gradientTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.gradientTexture);
                
                const white = new Uint8Array([255, 255, 255, 255]);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, white);
                
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            }

            setupUniforms() {
                const gl = this.gl;
                
                this.uniforms = {
                    uResolution: gl.getUniformLocation(this.program, 'uResolution'),
                    uTime: gl.getUniformLocation(this.program, 'uTime'),
                    uIntensity: gl.getUniformLocation(this.program, 'uIntensity'),
                    uSpeed: gl.getUniformLocation(this.program, 'uSpeed'),
                    uAnimType: gl.getUniformLocation(this.program, 'uAnimType'),
                    uMouse: gl.getUniformLocation(this.program, 'uMouse'),
                    uColorCount: gl.getUniformLocation(this.program, 'uColorCount'),
                    uDistort: gl.getUniformLocation(this.program, 'uDistort'),
                    uOffset: gl.getUniformLocation(this.program, 'uOffset'),
                    uGradient: gl.getUniformLocation(this.program, 'uGradient'),
                    uNoiseAmount: gl.getUniformLocation(this.program, 'uNoiseAmount'),
                    uRayCount: gl.getUniformLocation(this.program, 'uRayCount')
                };
                
                gl.uniform1i(this.uniforms.uGradient, 0);
                gl.uniform1f(this.uniforms.uIntensity, 2.0);
                gl.uniform1f(this.uniforms.uSpeed, 0.5);
                gl.uniform1i(this.uniforms.uAnimType, 1);
                gl.uniform2f(this.uniforms.uMouse, 0.5, 0.5);
                gl.uniform1i(this.uniforms.uColorCount, 0);
                gl.uniform1f(this.uniforms.uDistort, 0);
                gl.uniform2f(this.uniforms.uOffset, 0, 0);
                gl.uniform1f(this.uniforms.uNoiseAmount, 0.8);
                gl.uniform1i(this.uniforms.uRayCount, 0);
            }

            resize() {
                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                const w = this.container.clientWidth;
                const h = this.container.clientHeight;
                
                this.canvas.width = w * dpr;
                this.canvas.height = h * dpr;
                this.canvas.style.width = w + 'px';
                this.canvas.style.height = h + 'px';
                
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                this.gl.uniform2f(this.uniforms.uResolution, this.canvas.width, this.canvas.height);
            }

            onPointerMove(e) {
                const rect = this.container.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = (e.clientY - rect.top) / rect.height;
                this.mouseTarget = [Math.max(0, Math.min(1, x)), Math.max(0, Math.min(1, y))];
            }

            animate() {
                const now = performance.now();
                const dt = Math.max(0, now - this.lastTime) * 0.001;
                this.lastTime = now;
                
                if (!this.paused) {
                    this.accumTime += dt;
                }
                
                const tau = 0.02;
                const alpha = 1 - Math.exp(-dt / tau);
                this.mouseSmooth[0] += (this.mouseTarget[0] - this.mouseSmooth[0]) * alpha;
                this.mouseSmooth[1] += (this.mouseTarget[1] - this.mouseSmooth[1]) * alpha;
                
                this.gl.uniform2f(this.uniforms.uMouse, this.mouseSmooth[0], this.mouseSmooth[1]);
                this.gl.uniform1f(this.uniforms.uTime, this.accumTime);
                
                this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);
                
                requestAnimationFrame(() => this.animate());
            }

            setIntensity(val) {
                this.gl.uniform1f(this.uniforms.uIntensity, val);
            }

            setSpeed(val) {
                this.gl.uniform1f(this.uniforms.uSpeed, val);
            }

            setAnimType(val) {
                this.gl.uniform1i(this.uniforms.uAnimType, parseInt(val));
            }

            setDistort(val) {
                this.gl.uniform1f(this.uniforms.uDistort, val);
            }

            setRayCount(val) {
                this.gl.uniform1i(this.uniforms.uRayCount, parseInt(val));
            }

            setPaused(val) {
                this.paused = val;
            }
        }

        // Initialize
        const container = document.getElementById('container');
        const burst = new PrismaticBurst(container);

        // Controls
        const intensitySlider = document.getElementById('intensity');
        const speedSlider = document.getElementById('speed');
        const animTypeSelect = document.getElementById('animType');
        const distortSlider = document.getElementById('distort');
        const rayCountSlider = document.getElementById('rayCount');
        const pauseBtn = document.getElementById('pauseBtn');

        intensitySlider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('intensityVal').textContent = val.toFixed(1);
            burst.setIntensity(val);
        });

        speedSlider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('speedVal').textContent = val.toFixed(1);
            burst.setSpeed(val);
        });

        animTypeSelect.addEventListener('change', (e) => {
            burst.setAnimType(e.target.value);
        });

        distortSlider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('distortVal').textContent = val.toFixed(1);
            burst.setDistort(val);
        });

        rayCountSlider.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            document.getElementById('rayCountVal').textContent = val;
            burst.setRayCount(val);
        });

        let paused = false;
        pauseBtn.addEventListener('click', () => {
            paused = !paused;
            burst.setPaused(paused);
            pauseBtn.textContent = paused ? 'Resume' : 'Pause';
        });
    </script>
</body>
</html>
